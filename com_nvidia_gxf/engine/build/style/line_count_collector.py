"""Concatenate many .lccsv files into one monolithic .csv file for the whole repository.

This command should be run after a bazel build.

 SPDX-FileCopyrightText: Copyright (c) 2020 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 SPDX-License-Identifier: Apache-2.0

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
"""

import os
import subprocess


def fast_filter_search(root_dir, suffix):
    """Yield files that end with suffix recursively walking from the root directory."""
    # Unfortunately os.walk is very slow traversing a directory with many entries
    # (like a typical bazel output directory) so we instead use the find command and
    # parse the text output.
    command = f"find {root_dir} -iname '*{suffix}'"
    output = subprocess.check_output(command, shell=True)
    output = output.decode("utf-8")
    for line in output.split("\n"):
        path = line.strip()
        if not path:
            continue
        yield path


def iter_csvs(root_dir):
    """Yield csv files generated by line_count.bzl output in the root_dir."""
    for path in fast_filter_search(root_dir, suffix=".lccsv"):
        yield path


def main(root_dir, output_csv):
    """Traverse the root_dir for line count csv files, concatenate them, and then write the output in a streaming fashion to output_csv.

    For convenence the script also prints the csv output as it is constructed.
    """
    has_header = False
    with open(output_csv, "w") as w:
        for path in iter_csvs(root_dir):
            with open(path) as r:
                # Only emit one header for the output CSV file.
                if has_header:
                    next(r)
                has_header = True
                for line in r:
                    row = line.strip()
                    w.write(f"{row}\n")
                    print(row)


def _bazel_expand_path(path):
    """Convert a path to an absolute path when invoked from bazel_run."""
    path = os.path.expanduser(path)
    if os.path.isabs(path):
        return path
    build_work_dir = os.environ.get("BUILD_WORKING_DIRECTORY")
    if not build_work_dir:
        return path
    return os.path.join(build_work_dir, path)


if __name__ == "__main__":
    import argparse
    import pathlib

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "root_dir",
        help="Root directory to search for line counts. This is typically `bazel-out/`",
    )
    parser.add_argument(
        "output_csv", help="Output path for csv."
    )
    args = parser.parse_args()
    main(
        root_dir=_bazel_expand_path(args.root_dir),
        output_csv=_bazel_expand_path(args.output_csv),
    )

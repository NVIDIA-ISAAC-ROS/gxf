"""
 SPDX-FileCopyrightText: Copyright (c) 2020 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 SPDX-License-Identifier: Apache-2.0

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License..
"""

load(
    "@compdb//:aspects.bzl",
    "compilation_database_aspect",
    "CompilationAspect",
)

_line_count_bash_template = "; ".join([
    'pushd "{directory}"',
    'echo "{name},$({compile_cmd} | wc -l)" >> "$work_dir/{output_csv}"',
    'popd',
]) + "; "

def _line_count_impl(ctx):
    """Compute line count for each source file in the compilation db.

    The compilation database is generated by parsing the specified sources
    for compilation commands.

    The commands then are modified to remove Werror, and change the
    crosstool wrapper to point to gcc.

    After this, we add the -E flag to save output of the preprocessor and
    perform word count for all specified sources added to a csv.

    A helper utility in line_count.py can then walk the bazel-out directory
    and concatenate all csv outputs into a singular output for all source
    files.

    We use the .lccsv suffix instead of .csv to provide uniqueness during
    the csv discovery process in line_count.py
    """
    compilation_db = ctx.attr.src[CompilationAspect].compilation_db
    source_files = ctx.attr.src[OutputGroupInfo].source_files.to_list()

    output_csv = ctx.outputs.csv

    if len(source_files) == 0:
        if ctx.attr.mandatory:
            fail("`src` must be a target with at least one source or header.")
        else:
            return

    source_file_paths = [ f.path for f in source_files ]

    command = "export work_dir=\"$(pwd)\"; "
    command += "echo 'name,line_count' > '{output_csv}'; ".format(output_csv = output_csv.path)
    for entry in compilation_db.to_list():
        if entry.file in source_file_paths:
            compilation_command = entry.command.replace(
                "external/toolchain/crosstool/scripts/crosstool_wrapper_driver_is_not_gcc_host.py",
                # Dump preprocessor output and disable all warnings.
                "/usr/bin/gcc -E -w",
            )
            # Remove warnings that cause errors.
            compilation_command = compilation_command.replace(
                "-Werror",
                "",
            )
            command += _line_count_bash_template.format(
                directory = entry.directory,
                name = entry.file,
                compile_cmd = compilation_command,
                output_csv = output_csv.path,
            )

    ctx.actions.run_shell(
        outputs = [output_csv],
        inputs = source_files,
        command = command,
    )

line_count = rule(
    attrs = {
        "src": attr.label(
            aspects = [compilation_database_aspect],
            doc = "Source target to run line count on.",
            mandatory = True,
        ),
    },
    implementation = _line_count_impl,
    # Output custom .lccsv suffix to make discovery with line_count.py easy.
    outputs = {"csv": "%{name}.lccsv"},
)

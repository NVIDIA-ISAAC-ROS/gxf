#! /usr/env/python
# Copyright (c) 2020-2023, NVIDIA CORPORATION.  All rights reserved.
#
# NVIDIA CORPORATION and its licensors retain all intellectual property
# and proprietary rights in and to this software, related documentation
# and any modifications thereto.  Any use, reproduction, disclosure or
# distribution of this software and related documentation without an express
# license agreement from NVIDIA CORPORATION is strictly prohibited.
""" Registry CLI
"""

# Update python path to pick up relative packages
import sys
import argparse

from typing import List
from result import Ok, Err, Result
import tempfile
import yaml
import os
import shutil

from registry.cli.cli_pretty_format import PrettyFormatter
from registry.cli.cli_query_maker import QueryMaker
from registry.cli.cli_argparse_group_maker import make_parser
from registry.core.utils import PlatformConfig, ComputeConfig, \
                                TargetConfig, Variant
from registry.core.core_interface import Registry


def get_subparser(parser: argparse.ArgumentParser, subparser_name: str) \
        -> Result:
    """ The purpose of this function is to get one of the sub parser of the
    current parser. There is no method in argparse for that right now.
    :param parser: The parser generated by Argparse
    :param subparser_name: The name of the sub parser to get
    :return: The sub parser which name was provided if found, and error
    message otherwise.
    """
    subparsers_actions = [
        action for action in parser._actions
        if isinstance(action, argparse._SubParsersAction)]
    for subparsers_action in subparsers_actions:
        for name, sub_parser in subparsers_action.choices.items():
            # cannot access it directly as a dict... weird
            if subparser_name == name:
                return Ok(sub_parser)
    return Err("No sub parser with the name {}".format(subparser_name))


def get_nth_sub_parser(parser: argparse.ArgumentParser,
                       sub_parser_names: List[str]) -> Result:
    """ The purpose of this function is to get one of the nth sub parser
     of the current parser. There is no method in argparse for that right now.
    :param parser: The parser generated by Argparse
    :param sub_parser_names: A list of names to get to the sub parser to obtain
    :return: The sub parser which name was provided if found, and error
    message otherwise.
    """
    current_sub_parser = parser
    for elm in sub_parser_names:
        res = get_subparser(current_sub_parser, elm)
        if res.is_err():
            return Err("Cannot get nth sub parser with name: {}".format(elm))
        current_sub_parser = res.value
    return Ok(current_sub_parser)

class ParserError:
    """ Container for an error message and a parser.
    """

    def __init__(self, error_message: str,
                 parser: argparse.ArgumentParser):
        self._error_message = error_message
        self._parser = parser

    def display(self):
        print(self._error_message)
        if self._parser:
            print()
            self._parser.print_help()


class CacheHandler:
    """ A class to call functions related to the cache.
    """

    def __init__(self, registry: Registry, parser: argparse.ArgumentParser):
        self.registry = registry
        self.parser = parser
        self.name = "cache"

    def clean(self) -> Result:
        return self.registry.clear_cache()

    def refresh(self) -> Result:
        return self.registry.refresh_cache()

    def set(self, path: str) -> Result:
        return self.registry.set_cache_path(path)

    def view(self) -> Result:
        return self.registry.get_cache_path()

    def execute_on(self, args: dict) -> Result:
        """ Select which method to call with the provided arguments
        :param args: The argument dictionary provided by argparse
        :return: A Result object containing a string with information
        related to the chosen command.
        """
        res: Result
        if args["clean"]:
            res = self.clean()
        elif args["refresh"]:
            res = self.refresh()
        elif args["view"]:
            res = self.view()
        elif "set" in args and args["set"] and len(args["set"]) == 1:
            res = self.set(args["set"][0])
        else:
            res = Err("Missing option")

        if res.is_err():
            subparser_res = get_subparser(self.parser, self.name)
            if not subparser_res:
                return Err("Missing sub parser for {}".format(self.name))
            return Err(ParserError(res.value, subparser_res.value))
        return res


def call_subparsers(parser: argparse.ArgumentParser, args: dict,
                    command_keywords: List[str],
                    nth_sub_parser_name: str, handlers,
                    function_list_no_arg: list = None):
    """
    :param parser: current parser
    :param args: argument dictionary provided by argparse
    :param command_keywords: the keywords related to the sub parser to use
    :param nth_sub_parser_name: the name of the key in the dictionary containing
    the methods to use.
    :param handlers: Dictionary containing the methods to use.
    :param function_list_no_arg: list of the keys related to methods that
    require no arguments as entry.
    :return: A Result object containing a string with information
        related to the chosen command.
    """
    ssp_res = get_nth_sub_parser(parser, command_keywords)
    ssp = ssp_res.value if ssp_res.is_ok() else None
    if nth_sub_parser_name not in args:
        return Err(ParserError("Missing argument", ssp))

    ssp_name = args[nth_sub_parser_name]
    if ssp_name not in handlers:
        return Err(ParserError("Bad Argument: {}".format(ssp_name), ssp))

    if not function_list_no_arg:
        function_list_no_arg = []

    temp_result: Result
    if ssp_name in function_list_no_arg:
        temp_result = handlers[ssp_name]()
    else:
        temp_result = handlers[ssp_name](args)
    return temp_result


def field_exist_with_unique_elm(args: dict, field_name: str) -> Result:
    """ Checks if a field exists, is a list and has only one element in  a
    dictionary provided by argparse
    :param args: Dictionary provided by argparse with user entry
    :param field_name: Name of the field to check
    :return: Result with an error message inside if any error was encountered
    """

    err_str = ""
    if field_name not in args:
        err_str = "Missing \"{}\" field. Use -h for help menu".format(field_name)
    elif args[field_name] is None:
        err_str = "Missing \"{}\" field. Use -h for help menu".format(field_name)

    return Ok() if err_str == "" else Err(err_str)


def check_field_list_of_arguments(args: dict, field_names: List[str]) -> Result:
    """
    :param args: Dictionary provided by argparse with user entry
    :param field_names: list of element to check
    :return: Result containing a string with the first error encountered
    in case of Err or nothing in case of Ok
    """
    for elm in field_names:
        res = field_exist_with_unique_elm(args, elm)
        if res.is_err():
            return res
    return Ok()


class RepoHandler:
    """ A class to call functions related to the Repository.
    """

    def __init__(self, registry: Registry, parser: argparse.ArgumentParser):
        self.registry = registry
        self.parser = parser
        self.name = "repo"
        self.sub_parser_handlers = {"clean": self.clean,
                                    "add": self.add,
                                    "remove": self.remove,
                                    "list": self.list,
                                    "sync": self.sync,
                                    "info": self.info}
        self.sub_parser_add = {"ngc": self.add_ngc}

    @classmethod
    def get_elm_if_exist(cls, args, x):
        if x in args and args[x] and len(args[x]) == 1:
            return args[x][0]
        return None

    def clean(self) -> Result:
        return self.registry.clean_default_repo()

    def add_ngc(self, args: dict) -> Result:
        res = check_field_list_of_arguments(args, ["name", "org", "apikey"])
        if res.is_err():
            return res
        name = self.get_elm_if_exist(args, "name")
        org = self.get_elm_if_exist(args, "org")
        apikey = self.get_elm_if_exist(args, "apikey")
        team = self.get_elm_if_exist(args, "team")

        res = self.registry.add_ngc_repo(name, org, apikey, team)
        return res

    def add(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the chosen add command.
        """
        temp_result = call_subparsers(self.parser, args, [self.name, "add"],
                                      "subsubparser_name",
                                      self.sub_parser_add)
        return temp_result

    def remove(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the remove command.
        """
        res = check_field_list_of_arguments(args, ["name"])
        if res.is_err():
            return res
        name = self.get_elm_if_exist(args, "name")
        res = self.registry.remove_repo(name)
        if res.is_ok():
            return Ok("Repository successfully removed")
        return res

    def list(self, args: dict) -> Result:
        """
        :return: A Result object containing a string with information
        related to the list command.
        """
        details = "details" in args and args["details"]
        res = self.registry.get_repo_list()
        if res.is_err():
            return res
        str_list = PrettyFormatter.repository_list(res.value, details)
        return Ok(str_list)

    def info(self, args: dict) -> Result:
        """
        :return: A Result object containing a string with information
        related to the info command.
        """
        res = check_field_list_of_arguments(args, ["name"])
        if res.is_err():
            return res
        name = self.get_elm_if_exist(args, "name")
        res = self.registry.get_repo_info(name)
        if res.is_err():
            return res
        str_info = PrettyFormatter.repository(res.value, True, True)
        return Ok(str_info)

    def sync(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the sync command.
        """
        res = check_field_list_of_arguments(args, ["name"])
        if res.is_err():
            return res

        name = self.get_elm_if_exist(args, "name")
        res = self.registry.sync_repo(name)
        return res

    def execute_on(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the chosen command.
        """
        temp_result = call_subparsers(self.parser, args, [self.name],
                                      "subparser_name",
                                      self.sub_parser_handlers, ["clean"])
        return temp_result


class GraphHandler:
    """ A class to call functions related to the Graph.
    """

    def __init__(self, registry: Registry, parser: argparse.ArgumentParser):
        self.registry = registry
        self.parser = parser
        self.name = "graph"
        self.subparser_handlers = {"install": self.install,
                                   "update": self.update }

    @classmethod
    def get_elm_if_exist(cls, args, x):
        if x in args and args[x] and len(args[x]) == 1:
            return args[x][0]
        return None

    @classmethod
    def get_list_elm_if_exist(cls, args, x):
        if x in args and args[x]:
            return args[x]
        return None

    @classmethod
    def replace_if_none(cls, src, replacement):
        if src is None:
            return replacement
        return src

    def install(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the install command.
        """
        res = check_field_list_of_arguments(args, ["graph_files",
                                                   "mnf_filepath", "target_filepath"])
        if res.is_err():
            return res
        # mandatory
        graph_files = self.get_list_elm_if_exist(args, "graph_files")
        manifest_fp = self.get_elm_if_exist(args, "mnf_filepath")
        target_fp = self.get_elm_if_exist(args, "target_filepath")

        # optional
        # sm_arch = self.get_elm_if_exist(args, "sm_arch")
        archive_dp = self.get_elm_if_exist(args, "archive_dirpath")
        in_export_dp = self.get_elm_if_exist(args, "in_export_dirpath")
        output_dp = self.get_elm_if_exist(args, "output_dir")

        if not archive_dp and not output_dp:
            return Err("Atleast one option has to be selected amongst"
                       " --output-directory and --archive-dir-path ")

        if archive_dp is not None:
            export_dp = self.replace_if_none(in_export_dp, "/opt/nvidia/nvgraph/")
            result = self.registry.install_graph_with_archive(graph_files,
                                                              manifest_fp, archive_dp,
                                                              export_dp, target_fp)
            if result.is_err():
                return result

        if output_dp is not None:
            export_dp = self.replace_if_none(in_export_dp, "")
            result = self.registry.install_graph_with_dir(graph_files,
                                                          manifest_fp, output_dp,
                                                          export_dp, target_fp)

        return result

    def update(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the install command.
        """
        res = check_field_list_of_arguments(args, ["graph_files"])
        if res.is_err():
            return res

        # mandatory
        graph_files = self.get_list_elm_if_exist(args, "graph_files")

        result = self.registry.update_graph_dependencies(graph_files)
        return result

    def execute_on(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the chosen command.
        """
        temp_result = call_subparsers(self.parser, args, [self.name],
                                      "subparser_name",
                                      self.subparser_handlers, [])
        return temp_result


class CompoHandler:
    """ A class to call functions related to the Component.
    """

    def __init__(self, registry: Registry, parser: argparse.ArgumentParser):
        self.registry = registry
        self.parser = parser
        self.name = "comp"
        self.subparser_handlers = {"info": self.info,
                                   "list": self.list}

    def info(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the info command.
        """
        res = check_field_list_of_arguments(args, ["type"])
        if res.is_err():
            return res
        typename = args["type"][0]
        res = QueryMaker(self.registry) \
            .add_constraint_exact_match_field("typename", typename) \
            .get_for_component()
        if res.is_err() or not res.value:
            res_set_components = QueryMaker(self.registry) \
                .all_existing_attribute_components("typename")
            if res_set_components.is_err():
                return res_set_components
            list_typenames = list(res_set_components.value)
            str_err = f"Component typename not found!"
            if list_typenames:
                str_err += "Please use one of " \
                      "the following types:\n"
                str_err += PrettyFormatter.string_list(list_typenames)
            return Err(str_err)
        res_comp = Ok(res.value[0])
        res_param = self.registry.get_param_list(res.value[0].cid)
        return PrettyFormatter.component_info(res_comp, res_param)

    @classmethod
    def get_elm_if_exist(cls, args, x):
        if x in args and args[x] and len(args[x]) == 1:
            return args[x][0]
        return None

    def list(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the list command.
        """

        base_typename = self.get_elm_if_exist(args, "base_type")
        typename = self.get_elm_if_exist(args, "typename")
        repo_name = self.get_elm_if_exist(args, "repo_name")
        qm = QueryMaker(self.registry)
        if repo_name:
            res = qm.set_repo_name(repo_name)
            if res.is_err():
                return res
        if base_typename:
            qm.add_constraint_exact_match_field("base_typename", base_typename)
        if typename:
            qm.add_constraint_exact_match_field("typename", typename)
        res_comp_list = qm.get_for_component()
        if res_comp_list.is_err() or not res_comp_list.value:
            str_err = ""
            if base_typename or typename:
                str_err += "No component matching the provided options."
                constraints = [("base_typename", base_typename),
                               ("typename", typename)]
                for k, v in constraints:
                    if v:
                        str_err += PrettyFormatter.filtering_possibilities(
                            qm.all_existing_attribute_components, k)
            if str_err == "":
                str_err = "No components found"
            return Err(str_err)

        if not res_comp_list.value:
            str_err = PrettyFormatter.filtering_possibilities(
                qm.all_existing_attribute_components, "base_typename")
            return Err(str_err)
        return PrettyFormatter.component_list(res_comp_list)

    def execute_on(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the chosen command.
        """
        temp_result = call_subparsers(self.parser, args, [self.name],
                                      "subparser_name",
                                      self.subparser_handlers)
        return temp_result


class ExtnHandler:
    """ A class to call functions related to the Extension.
    """

    @classmethod
    def get_elm_if_exist(cls, args, x):
        if x in args and args[x] and len(args[x]) == 1:
            return args[x][0]
        return None

    def __init__(self, registry: Registry, parser: argparse.ArgumentParser):
        self.registry = registry
        self.parser = parser
        self.name = "extn"
        self.subparser_handlers = {"add": self.add,
                                   "remove": self.remove,
                                   "list": self.list,
                                   "publish": self.publish,
                                   "import": self.import_extension,
                                   "install": self.install,
                                   "sync": self.sync,
                                   "versions": self.versions,
                                   "variants": self.variants,
                                   "info": self.info,
                                   "dependencies": self.dependencies}

        self.sub_parser_publish = {"all": self.publish_all,
                                   "one": self.publish_one,
                                   "interface": self.publish_interface,
                                   "variant": self.publish_variant}

        self.sub_parser_remove = {"all": self.remove_all,
                                  "one": self.remove_one,
                                  "interface": self.remove_interface,
                                  "variant": self.remove_variant}

        self.sub_parser_import = {"interface": self.import_interface,
                                  "variant": self.import_variant}

    def add(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the chosen add command.
        """
        mnf_name = self.get_elm_if_exist(args, "mnf_name")
        meta_file = self.get_elm_if_exist(args, "meta_file")
        if mnf_name:
            return self.registry.add_extension_from_manifest(mnf_name,
                                                             meta_file)
        res_parser = get_nth_sub_parser(self.parser, ["extn", "add"])
        if res_parser.is_ok():
            parser: argparse.ArgumentParser = res_parser.value
            return Err(parser.format_help())
        return Err("Parser error")

    def remove(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the remove command.
        """

        result = call_subparsers(self.parser, args, [self.name, "remove"],
                                      "subsubparser_name",
                                      self.sub_parser_remove)
        return result

    def remove_interface(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the remove interface command.
        """

        res = check_field_list_of_arguments(args,
              ["repo_name", "extn_name", "select_version"])
        if res.is_err():
            return res
        # required
        repo = self.get_elm_if_exist(args, "repo_name")
        ename = self.get_elm_if_exist(args, "extn_name")
        version = self.get_elm_if_exist(args, "select_version")

        # optional
        uuid = self.get_elm_if_exist(args, "uuid")
        return self.registry.remove_extension_interface(ename, version, repo, uuid)

    def remove_variant(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the remove variant command.
        """

        res = check_field_list_of_arguments(args,
              ["repo_name", "extn_name", "arch", "distribution", "os", "select_version"])
        if res.is_err():
            return res
        # required
        repo = self.get_elm_if_exist(args, "repo_name")
        ename = self.get_elm_if_exist(args, "extn_name")
        arch = self.get_elm_if_exist(args, "arch")
        distribution = self.get_elm_if_exist(args, "distribution")
        os = self.get_elm_if_exist(args, "os")
        version = self.get_elm_if_exist(args, "select_version")

        # optional
        cuda = self.get_elm_if_exist(args, "cuda")
        cudnn = self.get_elm_if_exist(args, "cudnn")
        tensorrt = self.get_elm_if_exist(args, "tensorrt")
        deepstream = self.get_elm_if_exist(args, "deepstream")
        triton = self.get_elm_if_exist(args, "triton")
        vpi = self.get_elm_if_exist(args, "vpi")
        uuid = self.get_elm_if_exist(args, "uuid")

        platform_cfg = PlatformConfig(arch, os, distribution)
        compute_cfg = ComputeConfig(cuda, cudnn, tensorrt, deepstream, triton, vpi)
        target_cfg =TargetConfig(platform_cfg, compute_cfg)

        return self.registry.remove_extension_variant(ename, version, repo, target_cfg, uuid)

    def remove_one(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the remove all command.
        """
        res = check_field_list_of_arguments(args,["extn_name", "select_version"])
        if res.is_err():
            return res

        ename = self.get_elm_if_exist(args, "extn_name")
        version = self.get_elm_if_exist(args, "select_version")

        return self.registry.remove_extension(ename, version)

    def remove_all(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the remove all command.
        """

        res = check_field_list_of_arguments(args,["repo_name"])
        if res.is_err():
            return res
        # required
        repo = self.get_elm_if_exist(args, "repo_name")

        answer = input(f"Are you sure you want to remove all the extensions in {repo}? [Yes/No]")
        if answer == "Yes" or answer == "yes":
            return self.registry.remove_all_extensions(repo)
        elif answer == "No" or answer == "no":
            return Ok("Extensions not removed")
        return Err(f"Invalid answer {answer}")

    def list(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the list command.
        """

        repo_name = self.get_elm_if_exist(args, "repo_name")
        name = self.get_elm_if_exist(args, "name")
        author = self.get_elm_if_exist(args, "author")
        labels = None
        if "labels" in args and args["labels"]:
            labels = args["labels"]

        qm = QueryMaker(self.registry)
        if repo_name:
            res = qm.set_repo_name(repo_name)
            if res.is_err():
                return res
        if name:
            qm.add_constraint_exact_match_field("name", name)
        if author:
            qm.add_constraint_exact_match_field("author", author)
        if labels:
            for lbl in labels:
                qm.add_constraint_inside_field("labels", lbl)
        res = qm.get_for_extension()
        if res.is_err() or not res.value:
            str_err = ""
            if name or author or labels:
                str_err += "No extension matching the provided options."
                constraints = [("name", name), ("author", author),
                               ("labels", labels)]
                for k, v in constraints:
                    if v:
                        str_err += PrettyFormatter.filtering_possibilities(
                            qm.all_existing_attribute_extensions, k)
            if str_err == "":
                str_err = "No extension found"
            return Err(str_err)
        return PrettyFormatter.extension_list(res)

    def publish(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the publish command.
        """

        result = call_subparsers(self.parser, args, [self.name, "publish"],
                                      "subsubparser_name",
                                      self.sub_parser_publish)
        return result

    def publish_variant(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the publish variant command.
        """

        res = check_field_list_of_arguments(args,
              ["repo_name", "extn_name", "arch", "distribution", "os"])
        if res.is_err():
            return res
        # required
        repo = self.get_elm_if_exist(args, "repo_name")
        ename = self.get_elm_if_exist(args, "extn_name")
        arch = self.get_elm_if_exist(args, "arch")
        distribution = self.get_elm_if_exist(args, "distribution")
        os = self.get_elm_if_exist(args, "os")

        # optional
        cuda = self.get_elm_if_exist(args, "cuda")
        cudnn = self.get_elm_if_exist(args, "cudnn")
        tensorrt = self.get_elm_if_exist(args, "tensorrt")
        deepstream = self.get_elm_if_exist(args, "deepstream")
        triton = self.get_elm_if_exist(args, "triton")
        vpi = self.get_elm_if_exist(args, "vpi")
        uuid = self.get_elm_if_exist(args, "uuid")
        uuid = self.get_elm_if_exist(args, "uuid")
        log = self.get_elm_if_exist(args, "log")

        platform_cfg = PlatformConfig(arch, os, distribution)
        compute_cfg = ComputeConfig(cuda, cudnn, tensorrt, deepstream, triton, vpi)
        target_cfg =TargetConfig(platform_cfg, compute_cfg)

        return self.registry.publish_extension_variant(ename, repo, target_cfg, uuid, log)

    def publish_interface(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the publish interface command.
        """

        res = check_field_list_of_arguments(args,
              ["repo_name", "extn_name"])
        if res.is_err():
            return res
        # required
        repo = self.get_elm_if_exist(args, "repo_name")
        ename = self.get_elm_if_exist(args, "extn_name")

        # optional
        uuid = self.get_elm_if_exist(args, "uuid")
        log = self.get_elm_if_exist(args, "log")
        force = "force" in args and args["force"]

        return self.registry.publish_extension_interface(ename, repo, uuid, log, force)

    def publish_all(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the publish all command.
        """

        res = check_field_list_of_arguments(args,["repo_name"])
        if res.is_err():
            return res
        # required
        repo = self.get_elm_if_exist(args, "repo_name")
        # Optional
        force = "force" in args and args["force"]

        return self.registry.publish_all_extensions(repo, force)

    def publish_one(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the publish all command.
        """

        res = check_field_list_of_arguments(args,["repo_name", "extn_name"])
        if res.is_err():
            return res
        # required
        repo = self.get_elm_if_exist(args, "repo_name")
        ext_name = self.get_elm_if_exist(args, "extn_name")

        # Optional
        force = "force" in args and args["force"]
        return self.registry.publish_extension(ext_name, repo, force)

    def install(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the import interface command.
        """
        res = check_field_list_of_arguments(args, ["extn_name"])
        if res.is_err():
            return res
        # required
        extn_name = self.get_elm_if_exist(args, "extn_name")

        # optional
        ext_ver = self.get_elm_if_exist(args, "select_version")
        target_fp = self.get_elm_if_exist(args, "target_filepath")

        return self.registry.install_extension(extn_name, target_fp, ext_ver)

    def import_extension(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the import_extension command.
        """

        result = call_subparsers(self.parser, args, [self.name, "import_extension"],
                                      "subsubparser_name",
                                      self.sub_parser_import)
        return result

    def import_interface(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the import interface command.
        """

        res = check_field_list_of_arguments(args,
              ["extn_name", "select_version","directory"])
        if res.is_err():
            return res
        # required
        ename = self.get_elm_if_exist(args, "extn_name")
        version = self.get_elm_if_exist(args, "select_version")
        directory = self.get_elm_if_exist(args, "directory")

        # optional
        uuid = self.get_elm_if_exist(args, "uuid")
        return self.registry.import_extension_interface(ename, version, directory, uuid)

    def import_variant(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the import variant command.
        """
        res = check_field_list_of_arguments(
            args, ["arch", "distribution", "os", "directory", "select_version", "extn_name"])
        if res.is_err():
            return res

        # required
        arch = self.get_elm_if_exist(args, "arch")
        distribution = self.get_elm_if_exist(args, "distribution")
        os = self.get_elm_if_exist(args, "os")
        directory = self.get_elm_if_exist(args, "directory")
        version = self.get_elm_if_exist(args, "select_version")
        extn_name = self.get_elm_if_exist(args, "extn_name")

        # optional
        cuda = self.get_elm_if_exist(args, "cuda")
        cudnn = self.get_elm_if_exist(args, "cudnn")
        tensorrt = self.get_elm_if_exist(args, "tensorrt")
        deepstream = self.get_elm_if_exist(args, "deepstream")
        triton = self.get_elm_if_exist(args, "triton")
        vpi = self.get_elm_if_exist(args, "vpi")
        uuid = self.get_elm_if_exist(args, "uuid")
        uuid = self.get_elm_if_exist(args, "uuid")

        platform_cfg = PlatformConfig(arch, os, distribution)
        compute_cfg = ComputeConfig(cuda, cudnn, tensorrt, deepstream, triton, vpi)
        target_cfg =TargetConfig(platform_cfg, compute_cfg)

        return self.registry.import_extension_variant(extn_name, version, target_cfg, directory, uuid)

    def sync(self, args: dict) -> Result:
        res = check_field_list_of_arguments(
            args, ["repo_name", "extn_name", "select_version"])
        if res.is_err():
            return res
        # required
        repo_name = self.get_elm_if_exist(args, "repo_name")
        extn_name = self.get_elm_if_exist(args, "extn_name")
        select_version = self.get_elm_if_exist(args, "select_version")

        # optional
        uuid = self.get_elm_if_exist(args, "uuid")

        return self.registry.sync_extension(repo_name, extn_name,
                                            select_version, uuid)

    def versions(self, args: dict) -> Result:
        res = check_field_list_of_arguments(
            args, ["name"])
        if res.is_err():
            return res

        extn_name = self.get_elm_if_exist(args, "name")
        res = self.registry.get_extension_versions(extn_name)
        if res.is_err():
            return res
        to_display = f"{extn_name} Versions:\n"
        to_display += PrettyFormatter.dict_of_string_list(res.value)
        return Ok(to_display)

    def dependencies(self, args: dict)-> Result:
        res = check_field_list_of_arguments(
            args, ["name", "select_version"])
        if res.is_err():
            return res

        extn_name = self.get_elm_if_exist(args, "name")
        extn_version = self.get_elm_if_exist(args, "select_version")
        res = self.registry.get_extension_dependencies(extn_name, extn_version)
        if res.is_err():
            return res
        to_display = ""
        if len(res.value) == 0:
            to_display = "Extension has no dependencies"
        else:
            to_display = f"{extn_name} : {extn_version}\nDependencies:\n"
            to_display += PrettyFormatter.extension_dependencies(res.value)
        return Ok(to_display)

    def variants(self, args: dict) -> Result:
        res = check_field_list_of_arguments(
            args, ["name", "vers"])
        if res.is_err():
            return res

        extn_name = self.get_elm_if_exist(args, "name")
        version = self.get_elm_if_exist(args, "vers")
        res = self.registry.get_extension_variants(extn_name, version)
        if res.is_err():
            return res
        to_display = f"{extn_name}\nVariants:\n"
        to_display += PrettyFormatter.variant_list(res.value)
        return Ok(to_display)

    def info(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the info command.
        """

        ename = self.get_elm_if_exist(args, "extn_name")
        qm = QueryMaker(self.registry)
        qm.add_constraint_exact_match_field("name", ename)
        res = qm.get_for_extension()
        if res.is_err() or not res.value:
            res_all_name = qm.all_existing_attribute_extensions("name")
            if res_all_name.is_err():
                return res_all_name
            str_err = f"Extension name not found!"
            if res_all_name.value:
                str_err += "\nPlease choose among the following:\n"
                list_names = list(res_all_name.value)
                str_err += PrettyFormatter.string_list(list_names)
            return Err(str_err)
        res_e = res.value[0]
        res_c = self.registry.get_component_list(res_e.id)
        return PrettyFormatter.extension_info(Ok(res_e), res_c)

    def execute_on(self, args: dict) -> Result:
        """
        :param args: Dictionary provided by argparse with user entry
        :return: A Result object containing a string with information
        related to the chosen command.
        """
        temp_result = call_subparsers(self.parser, args, [self.name],
                                      "subparser_name",
                                      self.subparser_handlers)
        return temp_result


class RegistryCLI:
    """ GFX Registry CLI class, which redirects to handlers related to a
    chosen command.
    """

    def __init__(self):
        self.parser = make_parser()
        self.registry = Registry()
        self.handlers = {"cache": CacheHandler,
                         "repo": RepoHandler,
                         "comp": CompoHandler,
                         "graph": GraphHandler,
                         "extn": ExtnHandler,
                        }

    def read_entry(self, argv) -> dict:
        return vars(self.parser.parse_args(argv))

    def handle_version(self) -> Result:
        res = self.registry.get_versions()
        return PrettyFormatter.versions(res)

    def handle_missing_arg(self) -> Result:
        return Err(ParserError("Missing argument", self.parser))

    def execute(self, entry: dict) -> Result:
        if entry["version"]:
            return self.handle_version()
        parser_name = entry["parser_name"]
        if parser_name in self.handlers.keys():
            handler = self.handlers[parser_name](self.registry, self.parser)
            return handler.execute_on(entry)
        return self.handle_missing_arg()

    @staticmethod
    def display_error(res: Err):
        """ The purpose of this function is to display errors that were
            generated in deeper scopes.
        """
        val = res.value
        if isinstance(val, ParserError):
            val.display()
        elif isinstance(val, str):
            print(val)
        else:
            print("Cannot display error: bad type")

    def read_entry_and_execute(self, argv):
        entry = self.read_entry(argv)
        res = self.execute(entry)
        if res.is_ok():
            if isinstance(res.value, str):
                print(res.value)
            sys.exit(0)
        else:
            self.display_error(res)
            sys.exit(1)


def main(argv):
    try:
        cli_registry = RegistryCLI()
        cli_registry.read_entry_and_execute(argv)
    except OSError as error:
        print(error)
        sys.exit(1)


if __name__ == "__main__":
    main(sys.argv[1:])

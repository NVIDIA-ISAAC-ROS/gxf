"""
Copyright (c) 2023, NVIDIA CORPORATION. All rights reserved.

NVIDIA CORPORATION and its licensors retain all intellectual property
and proprietary rights in and to this software, related documentation
and any modifications thereto. Any use, reproduction, disclosure or
distribution of this software and related documentation without an express
license agreement from NVIDIA CORPORATION is strictly prohibited.
"""

load("@bazel_skylib//lib:selects.bzl", "selects")
load("@com_nvidia_gxf//gxf:gxf.bzl", "GraphCollector")
load("@com_nvidia_gxf//registry/build:defs.bzl",
     "get_platform_arch",
     "get_platform_os",
     "get_platform_os_distribution",
     "get_cuda_version",
     "get_cudnn_version",
     "get_tensorrt_version",
     "get_deepstream_version",
     "get_triton_version",
     "get_vpi_version")

# A wrapper over gxf_registry_app_rule, this macros executes a gxf app using extensions from
# the gxf registry rather than bazel cache. The macro takes all graphs, sub graphs and any data
# files as input. The extensions needed to execute the graphs should be listed in a yaml doc in any of the
# graph files in the following format.
#
# ---
# dependencies:
# - extension: StandardExtension
#   uuid: 8ec2d5d6-b5df-48bf-8dee-0252606fdd7e
#   version: 2.3.0
# - extension: TestHelperExtension
#   uuid: 1b99ffeb-c250-4ced-8117-62ac05969a50
#   version: 2.3.0
# - extension: SampleExtension
#   uuid: a6ad78b6-1682-11ec-9621-0242ac130002
#   version: 1.3.0
# ---
#
# Gxf registry will import any extension needed for execution from corresponding source repos. GXF registry
# currently supports both a local and NGC repositories. Caller of this function has to ensure the extensions
# needed to run this graph is available (sync'd) in the GXF registry.
#
# The target file required for installing the graph will be autogenerated based on the --config=<platform>
# selected for graph execution.

def gxf_registry_app(
        name,
        graphs,
        data = [],
        sub_graphs = [],
        visibility = None):

        arch = get_platform_arch()
        os = get_platform_os()
        distribution = get_platform_os_distribution()
        cuda = get_cuda_version()
        cudnn = get_cudnn_version()
        tensorrt = get_tensorrt_version()
        deepstream = get_deepstream_version()
        triton = get_triton_version()
        vpi = get_vpi_version()

        gxf_registry_app_rule(
            name = name,
            graphs = graphs,
            data = data,
            sub_graphs = sub_graphs,
            arch = arch,
            os = os,
            distribution = distribution,
            cuda = cuda,
            cudnn = cudnn,
            tensorrt = tensorrt,
            deepstream = deepstream,
            triton = triton,
            vpi = vpi,
            visibility = visibility,
        )


def _get_file_paths(f_list):
  files = []
  for f in f_list:
    files.append(f.path)
  return files

def _list_to_string_bash(list_ip):
  if len(list_ip) == 0:
    return "()"

  str = "("
  for l in list_ip:
    str += '"' + l + '" '
  str = str[:-1] + ')'

  return str

def _gxf_registry_app_impl(ctx):

  action_inputs = []
  action_inputs += ctx.attr._gxe[DefaultInfo].data_runfiles.files.to_list()
  action_inputs += ctx.attr._gxe[DefaultInfo].default_runfiles.files.to_list()
  action_inputs += ctx.attr._registry[DefaultInfo].data_runfiles.files.to_list()
  action_inputs += ctx.attr._registry[DefaultInfo].default_runfiles.files.to_list()

  if ctx.attr.graphs:
        action_inputs += ctx.files.graphs
  if ctx.attr.data:
        action_inputs += ctx.files.data
  if ctx.attr.sub_graphs:
        action_inputs += ctx.files.sub_graphs

  # generate platform target file
  target_file = ctx.actions.declare_file(ctx.label.name + "_target.yaml")
  ctx.actions.expand_template(
      template = ctx.file._target_template,
      output = target_file,
      substitutions = {
          "{ARCH}": ctx.attr.arch,
          "{OS}": ctx.attr.os,
          "{DISTRIBUTION}": ctx.attr.distribution,
          "{CUDA}": ctx.attr.cuda,
          "{CUDNN}": ctx.attr.cudnn,
          "{TENSORRT}": ctx.attr.tensorrt,
          "{DEEPSTREAM}": ctx.attr.deepstream,
          "{TRITON}": ctx.attr.triton,
          "{VPI}": ctx.attr.vpi,
      },
      is_executable = False,
  )

  # Add target to action inputs
  action_inputs += [target_file]

  # Graph files
  graphs = [f.short_path for f in ctx.files.graphs]
  sub_graphs = []
  for sub_graph in ctx.attr.sub_graphs:
        for graph in sub_graph[GraphCollector].graphs :
                sub_graphs.extend([g.path for g in graph.files.to_list()])
                action_inputs += graph.files.to_list()

  # generate the run script
  run_script = ctx.actions.declare_file(ctx.label.name + "_run.sh")
  ctx.actions.expand_template(
      template = ctx.file._run_template,
      output = run_script,
      substitutions = {
          "{APP_NAME}": ctx.label.name,
          "{GRAPHS_INPUT}": _list_to_string_bash(graphs),
          "{SUB_GRAPHS_INPUT}": _list_to_string_bash(sub_graphs),
          "{TARGET_FILE}": target_file.short_path,
          "{MANIFEST_FILE}": ctx.label.name + "_manifest.yaml",
      },
      is_executable = True,
  )

  return [DefaultInfo(executable = run_script, runfiles=ctx.runfiles(action_inputs))]


gxf_registry_app_rule = rule(
  implementation = _gxf_registry_app_impl,
  executable = True,
  attrs =
  {
    "_gxe": attr.label(
            doc = "gxe runtime used to run graphs",
            allow_single_file = ["gxe"],
            default = "//gxf/gxe"),
    "_registry": attr.label(
            doc = "registry cli tool used to install graphs before running them",
            default = "//registry/cli:registry_cli"),
    "_run_template": attr.label(
            allow_single_file = [".sh.tpl"],
            default = "//registry/build:execute_graph.sh.tpl"),
    "_target_template": attr.label(
            allow_single_file = [".yaml.tpl"],
            default = "//registry/build:target.yaml.tpl"),
    "graphs": attr.label_list(
            doc = "graph application files",
            allow_files = [".yaml"]),
    "data": attr.label_list(
            doc = "data files required for app execution",
            allow_files = True),
    "sub_graphs": attr.label_list(
            doc = "sub graph files",
            providers = [GraphCollector],
            allow_files = True),
    "arch": attr.string(
            doc = "deployment plaform arch",
            mandatory = True),
    "os": attr.string(
            doc = "deployment plaform os",
            mandatory = True),
    "distribution": attr.string(
            doc = "deployment plaform distribution",
            mandatory = True),
    "cuda": attr.string(
            doc = "cuda compute stack version"),
    "cudnn": attr.string(
            doc = "cudnn compute stack version"),
    "tensorrt": attr.string(
            doc = "tensorrt compute stack version"),
    "deepstream": attr.string(
            doc = "deepstream compute stack version"),
    "triton": attr.string(
            doc = "triton compute stack version"),
    "vpi": attr.string(
            doc = "vpi compute stack version"),
  }
)

